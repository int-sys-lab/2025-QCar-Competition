# -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
#***NEED SETUP COMPETITION IN SAME DIRECTORY/FOLDER
#region : File Description and Imports

"""
vehicle_control.py

Skills acivity code for vehicle control lab guide.
Students will implement a vehicle speed and steering controller.
Please review Lab Guide - vehicle control PDF
"""
import os
import signal
import numpy as np
from threading import Thread
import time
import cv2
import pyqtgraph as pg

from pal.products.qcar import QCar, QCarGPS, QCarCameras, QCarRealSense, IS_PHYSICAL_QCAR
from pal.utilities.scope import MultiScope
from pal.utilities.math import wrap_to_pi
from hal.content.qcar_functions import QCarEKF
from hal.products.mats import SDCSRoadMap
import pal.resources.images as images
from hal.utilities.image_processing import ImageProcessing
from pal.utilities.vision import Camera3D

# -------------------------------- Time Parameters -----------------------------------------
# - tf: experiment duration in seconds.
# - startDelay: delay to give filters time to settle in seconds.
# - controllerUpdateRate: control update rate in Hz. Shouldn't exceed 500
tf = 120
startDelay = 0
controllerUpdateRate = 150

# -------------------------- Speed Control Parameters --------------------------------------
# - v_ref: desired velocity in m/s
# - K_p: proportional gain for speed controller
# - K_i: integral gain for speed controller
# - K_d: derivative gain for speed controller
v_ref = 0.75
K_p = 1
K_i = 0
K_d = 0.01

# -------------------------- Steering Control Parameters ----------------------------------
# - enableSteeringControl: whether or not to enable steering control
# - K_stanley: K gain for stanley controller
# - nodeSequence: list of nodes from roadmap. Used for trajectory generation.
enableSteeringControl = True
K_stanley = 1
# ---- Path Options ----
# To Pick Up and Drop Off Passenger and Return
nodeSequence = [10, 2, 4, 14, 20, 22, 9, 7, 14, 20, 22, 10]
# To go around track
#nodeSequence = [10, 2, 4, 14, 20, 22, 10]
#Long Path 1
#nodeSequence = [10, 2, 4, 14, 20, 9, 13, 19, 17, 15, 6, 8, 23, 21, 16, 18, 11, 12, 0, 2, 4, 14, 20, 22, 10]
#Long Path 2
#nodeSequence = [10, 2, 4, 14, 20, 9, 13, 19, 17, 15, 5, 3, 1, 8, 23, 21, 16, 18, 11, 12, 0, 2, 4, 14, 20, 22, 10]


#endregion
# -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --

#region : Initial setup
if enableSteeringControl:
    roadmap = SDCSRoadMap(leftHandTraffic=False)
    waypointSequence = roadmap.generate_path(nodeSequence)
    # Get position of first two nodes in the path
    pos1 = roadmap.get_node_pose(nodeSequence[0]).squeeze()[:2]
    pos2 = roadmap.get_node_pose(nodeSequence[1]).squeeze()[:2]

    # Compute heading between them
    heading = np.arctan2(pos2[1] - pos1[1], pos2[0] - pos1[0])

    # Combine position from node 0 with new heading
    initialPose = np.array([pos1[0], pos1[1], heading])
else:
    initialPose = [0, 0, 0]

#if not IS_PHYSICAL_QCAR:
#import Setup_Competition
#import Setup_Real_Scenario
#Setup_Real_Scenario.terminate()
#Setup_Real_Scenario.setup(initialPosition=[-1.205,-0.83,0.005], initialOrientation=[0,0,-44.7])

# Used to enable safe keyboard triggered shutdown
global KILL_THREAD
KILL_THREAD = False
def sig_handler(*args):
    global KILL_THREAD
    KILL_THREAD = True
signal.signal(signal.SIGINT, sig_handler)
#endregion

#----------------------Speed Controller-----------------------
class SpeedController:

    def __init__(self, kp=0, ki=0, kd=0):
        self.maxThrottle = 0.3

        self.kp = kp
        self.ki = ki
        self.kd = kd
        self.ei = 0
        self.prev_error = v_ref
        self.prev_filtered_de_dt = 0
        self.alpha = 0.2  # smoothing factor

    def update(self, v, v_ref, dt):
        
        e = v_ref - v
        self.ei += dt*e
        if dt == 0.0:
            dt = 0.001
        de_dt = (e - self.prev_error)/dt
        filtered_de_dt = (self.alpha * de_dt) + (1 - self.alpha) * self.prev_filtered_de_dt
        self.prev_filtered_de_dt = filtered_de_dt
        output = self.kp * e + self.ki * self.ei + self.kd * filtered_de_dt
        self.prev_error = e

        return np.clip(output, -self.maxThrottle, self.maxThrottle)
        
        return 0
#----------------------Steering Controller-----------------------
class SteeringController:

    def __init__(self, waypoints, k=1, cyclic=True):
        self.maxSteeringAngle = np.pi/6
        self.prev_filtered_de_dt = 0
        self.alpha_steering = 0.2 
        self.filtered_psi_derivative = 0  # smoothed derivative of heading error
        self.psi_prev = 0.0

        self.wp = waypoints
        self.N = len(waypoints[0, :])
        self.wpi = 0

        self.k = k
        self.cyclic = cyclic

        self.p_ref = (0, 0)
        self.th_ref = 0

        self.bias_cooldown_counter = 0
 
    def update(self, p, th, speed, dt):
        wp_1 = self.wp[:, np.mod(self.wpi, self.N-1)]
        wp_2 = self.wp[:, np.mod(self.wpi+1, self.N-1)]

        v = wp_2 - wp_1
        v_mag = np.linalg.norm(v)
        try:
         v_uv = v / v_mag
        except ZeroDivisionError:
            return 0

        tangent = np.arctan2(v_uv[1], v_uv[0])

        s = np.dot(p-wp_1, v_uv)

        if s >= v_mag:
         if  self.cyclic or self.wpi < self.N-2:
                self.wpi += 1

        ep = wp_1 + v_uv*s
        ct = ep - p
        dir = wrap_to_pi(np.arctan2(ct[1], ct[0]) - tangent)

        psi = wrap_to_pi(tangent-th)  # Heading error

        # Bias logic
        bias_strength = max(0.0, 1.0 - abs(psi) / (np.pi / 4))
        if abs(psi) > 0.2:
            self.bias_cooldown_counter = 30
        if self.bias_cooldown_counter > 0:
            self.bias_cooldown_counter -= 1
            bias_strength = 0

        lane_bias = 0.05 * bias_strength
        ect = np.linalg.norm(ct) * np.sign(dir)
        ect += lane_bias

        # === Add a deadzone for very small cross-track error ===
        if abs(ect) < 0.01:  # deadzone if less than 1cm
            ect = 0

        safe_speed = max(speed, 0.5)

        # New: Derivative smoothing on psi
        if not hasattr(self, 'psi_prev'):
         self.psi_prev = psi  # initialize on first run

        if dt == 0.0:
            psi_derivative = 0
        else:
            psi_derivative = (psi - self.psi_prev) / dt

        # Low-pass filter the heading error derivative
        self.filtered_psi_derivative = (self.alpha_steering * psi_derivative) + (1 - self.alpha_steering) * self.filtered_psi_derivative

        # Smoothed heading error
        headingError = psi + (0.1 * self.filtered_psi_derivative)

        self.psi_prev = psi

        steering = wrap_to_pi(headingError + np.arctan2(self.k * ect, safe_speed))

        self.p_ref = ep
        self.th_ref = tangent

        return np.clip(steering, -self.maxSteeringAngle, self.maxSteeringAngle)

        
        return 0
#------------------------Main Control Loop Function---------------------------------
def controlLoop():
    
    #region controlLoop setup
    global KILL_THREAD
    u = 0
    delta = 0
    # used to limit data sampling to 10hz
    countMax = controllerUpdateRate / 10
    count = 0
    #-------------------------Camera Initialization--------------------------
    cameraInterfacingLab = ImageInterpretation(
        imageSize=[[820,410], [64,48]],
        frameRate=np.array([30, 30]),
        streamInfo=[3, "RGB"],
        chessDims=6,
        boxSize=1
    )
 
    cameraMatrix  = np.array([
        [495.84,   0.00, 408.03],
        [0.00, 454.60, 181.21],
        [0.00,   0.00,   1.00]
    ])
    
    distortionCoefficients = np.array([
        -0.57513,
        0.37175,
        -0.00489,
        -0.00277,
        -0.11136
    ])
    cameraInterfacingLab.d435CamIntrinsics = cameraMatrix
    cameraInterfacingLab.d435DistParam = distortionCoefficients
    #----------------------"Global" Variables-----------------------
    timerStart = 0
    timerStart2 = 0
    stop7TimerStart = 0
    stop7TimerStarted = False
    stop8TimerStart = 0
    stop8TimerStarted = False
    carStopped = False
    carStopped2 = False
    carStopped3 = False
    carStopped4 = False
    carStopped5 = False
    carStopped6 = False
    carStopped7 = False
    carStopped8 = False
    StopLight = False
    StopLight2 = False
    StopLight3 = False
    StopLight4 = False
    imageWidth = 1280
    imageHeight = 720
    stopLight = True
    counter2 = 0
    counter3 = 0
    counter4 = 0
    counter5 = 0
    green_frame_count_1 = 0
    green_frame_count_2 = 0
    green_frame_count_3 = 0
    green_frame_count_4 = 0
    #myCam1  = Camera3D(mode='RGB&DEPTH', frameWidthRGB=imageWidth, frameHeightRGB=imageHeight)
    #------------------------------------------------------------------------------
    #endregion

    #region Controller initialization
    speedController = SpeedController(
        kp=K_p,
        ki=K_i,
        kd = K_d
    )
    if enableSteeringControl:
        steeringController = SteeringController(
            waypoints=waypointSequence,
            k=K_stanley
        )
    #endregion

    #region QCar interface setup
    qcar = QCar(readMode=1, frequency=controllerUpdateRate)
    if enableSteeringControl:
        ekf = QCarEKF(x_0=initialPose)
        gps = QCarGPS(initialPose=initialPose)
    else:
        gps = memoryview(b'')
    #endregion

    with qcar, gps:
        t0 = time.time()
        t=0
        counter = 0
        while (t < tf+startDelay) and (not KILL_THREAD):
            #region : Loop timing update
            tp = t
            t = time.time() - t0
            dt = t-tp
            #endregion

            #region : Read from sensors and update state estimates
            qcar.read()
            counter = counter + 1
            if (counter % 60 == 0):
                cameraInterfacingLab.d435Color.read_RGB()
            if enableSteeringControl:
                if gps.readGPS():
                    y_gps = np.array([
                        gps.position[0],
                        gps.position[1],
                        gps.orientation[2]
                    ])
                    ekf.update(
                        [qcar.motorTach, delta],
                        dt,
                        y_gps,
                        qcar.gyroscope[2],
                    )
                else:
                    ekf.update(
                        [qcar.motorTach, delta],
                        dt,
                        None,
                        qcar.gyroscope[2],
                    )

                x = ekf.x_hat[0,0]
                y = ekf.x_hat[1,0]
                th = ekf.x_hat[2,0]
                p = ( np.array([x, y])
                    + np.array([np.cos(th), np.sin(th)]) * 0.2)
            v = qcar.motorTach
            #endregion

            # Slow start adjustment
            if t < 3:  # first 5 seconds
                current_v_ref = 0.4  # slower speed 
                speedController.maxThrottle = 0.15  # half the original 0.3 throttle
            else:
                current_v_ref = v_ref
                speedController.maxThrottle = 0.3  # back to normal throttle
                
            turn_strength = abs(steeringController.psi_prev)
            if turn_strength > 0.2:
                speed_multiplier = 0.7  # slow down during sharp turns
            else:
                speed_multiplier = 1.0

            #region : Update controllers and write to car
            if t < startDelay:
                u = 0
                delta = 0
            else:
                #region : Speed controller update
                # One-time stop at passenger pick up for 3 seconds
                if not carStopped7 and abs(p[0] - 0.125) < 0.7 and abs(p[1] - 4.395) < 0.3:
                    if not stop7TimerStarted:
                        print("Picking up passenger")
                        u = 0
                        delta = 0
                        stop7TimerStart = time.time()
                        stop7TimerStarted = True
                    elif (time.time() - stop7TimerStart) < 3:
                        u = 0
                        delta = 0
                    else:
                        carStopped7 = True  # Don't stop again

                    qcar.write(u, delta)
                    continue  # Skip the rest of the loop this frame
                # One-time stop at passenger drop off for 3 seconds
                if not carStopped8 and abs(p[0] - (-0.905)) < 0.2 and abs(p[1] - 0.8) < 0.3:
                    if not stop8TimerStarted:
                        print("Dropping off passenger")
                        u = 0
                        delta = 0
                        stop8TimerStart = time.time()
                        stop8TimerStarted = True
                    elif (time.time() - stop8TimerStart) < 3:
                        u = 0
                        delta = 0
                    else:
                        carStopped8 = True  # Don't stop again

                    qcar.write(u, delta)
                    continue  # Skip the rest of the loop this frame
                
                if abs(p[0] - (-1.4)) < 0.2 and abs(p[1] - (-0.3)) < 0.3:
                #if np.linalg.norm(p - np.array([-1.6, -0.3])) < 0.35 and not carStopped6:
                    print("Final destination reached.")
                    u = 0
                    delta = 0
                    qcar.write(u, delta)
                    time.sleep(3)
                    break
                #Stop Sign 1----------------------------------------------------------
                if p[0] < 3.5 and p[0] > 2.11 and p[1] < 0.15 and p[1] > -.2:
                    #When car first enters box, stop car and start timer
                    if carStopped == False:
                        u = 0
                        timerStart = time.time()
                        carStopped = True
                    #When timer reaches 3 seconds, continue
                    else:
                        timerEnd = time.time()
                        if (timerEnd - timerStart) >= 3:
                            u = speedController.update(v, current_v_ref * speed_multiplier, dt)
                #Stop Sign 2-----------------------------------------------------------
                elif p[0] < 2.1 and p[0] > 1.85 and p[1] < 2.1 and p[1] > 1.7:
                    #When car first enters box, stop car and start timer
                    if carStopped2 == False:
                        u = 0
                        timerStart2 = time.time()
                        carStopped2 = True
                    #When timer reaches 3 seconds, continue
                    else:
                        timerEnd = time.time()
                        if (timerEnd - timerStart2) >= 3:
                            u = speedController.update(v, current_v_ref * speed_multiplier, dt)
                #Stop Light 1---------------------------------------------------------
                elif p[0] < -0.6 and p[0] > -1. and p[1] < 1 and p[1] > 0.7: 
                    #False as long as car has first entered box and light is assumed to be red                    
                    if (StopLight == False):
                        #count every second (counter2 starts from 0)
                        second = counter2 % 60
                        #if it has been one second, isSecond is true
                        if second == 0:
                            isSecond = True
                        else:
                            isSecond = False
                        #increment the counter every loop
                        counter2 = counter2 + 1
                        #if it has been one second, take a picture
                        if isSecond == True:
                            image = cameraInterfacingLab.d435Color.imageBufferRGB
                            #--------------------Image Processing------------------------
                            hsv_img = cv2.cvtColor(image, cv2.COLOR_BGR2HSV)
                            carStopped3 = True
                            # lower range of green stoplight color in HSV
                            hsv_green_lower = (40, 50, 100)
                            # upper range of green stoplight color in HSV
                            hsv_green_upper = (80, 255, 255)
                            #mask with the range of greens for stoplight color
                            mask = cv2.inRange(hsv_img, hsv_green_lower, hsv_green_upper)
                            #only show the pixels that contain the stoplight color
                            color_image = cv2.bitwise_and(image, image, mask=mask)

                            #print(np.average(color_image))
                            
                            #If the average pixel value is above 0.07, stoplight must be green
                            #if np.average(color_image) >= 0.07: 
                            green_pixels = np.count_nonzero(mask)
                            total_pixels = mask.shape[0] * mask.shape[1]
                            green_ratio = green_pixels / total_pixels

                            print(f"Green pixels: {green_pixels}, Ratio: {green_ratio:.5f}")

                            # --- New threshold logic ---
                            if green_ratio >= 0.0001 and green_pixels >= 100:
                                green_frame_count_1 += 1
                                print(f"Green frame count: {green_frame_count_1}")
                            else:
                                green_frame_count_1 = 0  # reset if not green

                            # Only GO if we have 3 green frames in a row
                            if green_frame_count_1 >= 3:
                                carStopped3 = False
                                print("Light is green go!")
                                StopLight = True
                                u = speedController.update(v, current_v_ref * speed_multiplier, dt)
                            #otherwise, stop at red light
                            else:
                                print("Light is red stop!")
                                u = 0
                                delta = 0
                #Stop Light 2--------------------------------------------------
                elif p[0] < 1.3 and p[0] > 0.9 and p[1] < 1.2  and p[1] > 0.95:
                    #False as long as car has first entered box and light is assumed to be red  
                    if (StopLight2 == False):
                        #count every second (counter2 starts from 0)
                        second = counter3 % 60
                        #if it has been one second, isSecond is true
                        if second == 0:
                            isSecond = True
                        else:
                            isSecond = False
                        #increment the counter every loop
                        counter3 = counter3 + 1
                        #if it has been one second, take a picture
                        if isSecond == True:
                            image = cameraInterfacingLab.d435Color.imageBufferRGB
                            #--------------------Image Processing------------------------
                            hsv_img = cv2.cvtColor(image, cv2.COLOR_BGR2HSV)
                            carStopped4 = True
                            # lower range of green stoplight color in HSV
                            hsv_green_lower = (40, 50, 100)
                            # upper range of green stoplight color in HSV
                            hsv_green_upper = (80, 255, 255)
                            # mask with the range of greens for stoplight color
                            mask = cv2.inRange(hsv_img, hsv_green_lower, hsv_green_upper)
                            # only show the pixels that contain the stoplight color
                            color_image = cv2.bitwise_and(image, image, mask=mask)

                            #print(np.average(color_image))
                            
                            #If the average pixel value is above 0.07, stoplight must be green
                            green_pixels = np.count_nonzero(mask)
                            #if np.average(color_image) > 0.071:
                            total_pixels = mask.shape[0] * mask.shape[1]
                            green_ratio = green_pixels / total_pixels

                            print(f"Green pixels: {green_pixels}, Ratio: {green_ratio:.5f}")

                            # --- New threshold logic ---
                            if green_ratio >= 0.0001 and green_pixels >= 50:
                                green_frame_count_2 += 1
                                print(f"Green frame count: {green_frame_count_2}")
                            else:
                                green_frame_count_2 = 0  # reset if not green

                            # Only GO if we have 3 green frames in a row
                            if green_frame_count_2 >= 3:
                                carStopped4 = False
                                print("Light is green go!")
                                StopLight2 = True
                                u = speedController.update(v, current_v_ref * speed_multiplier, dt)
                            #otherwise, stop at red light
                            else:
                                print("Light is red stop!")
                                u = 0
                                delta = 0
                #Stop Light 3---------------------------------------------------------
                elif p[0] < 0.1 and p[0] > -0.1 and p[1] < 2.15 and p[1] > 1.75:
                    #False as long as car has first entered box and light is assumed to be red                    
                    if (StopLight3 == False):
                        #count every second (counter2 starts from 0)
                        second = counter4 % 60
                        #if it has been one second, isSecond is true
                        if second == 0:
                            isSecond = True
                        else:
                            isSecond = False
                        #increment the counter every loop
                        counter4 = counter4 + 1
                        #if it has been one second, take a picture
                        if isSecond == True:
                            image = cameraInterfacingLab.d435Color.imageBufferRGB
                            #--------------------Image Processing------------------------
                            hsv_img = cv2.cvtColor(image, cv2.COLOR_BGR2HSV)
                            carStopped5 = True
                            # lower range of green stoplight color in HSV
                            hsv_green_lower = (40, 50, 100)
                            # upper range of green stoplight color in HSV
                            hsv_green_upper = (80, 255, 255)
                            #mask with the range of greens for stoplight color
                            mask = cv2.inRange(hsv_img, hsv_green_lower, hsv_green_upper)
                            #only show the pixels that contain the stoplight color
                            color_image = cv2.bitwise_and(image, image, mask=mask)

                            print(f"Green pixels: {green_pixels}, Ratio: {green_ratio:.5f}")

                            # --- New threshold logic ---
                            if green_ratio >= 0.0001 and green_pixels >= 50:
                                green_frame_count_3 += 1
                                print(f"Green frame count: {green_frame_count_3}")
                            else:
                                green_frame_count_3 = 0  # reset if not green

                            # Only GO if we have 3 green frames in a row
                            if green_frame_count_3 >= 3:
                            #If the average pixel value is above 0.07, stoplight must be green
                            #if np.average(color_image) >= 0.06: 
                                carStopped5 = False
                                print("Light is green go!")
                                StopLight = True
                                u = speedController.update(v, current_v_ref * speed_multiplier, dt)
                            #otherwise, stop at red light
                            else:
                                print("Light is red stop!")
                                u = 0
                                delta = 0
                #Stop Light 4---------------------------------------------------------
                elif p[0] < 0.38 and p[0] > 0.1 and p[1] < 0.2 and p[1] > -0.2:
                    #False as long as car has first entered box and light is assumed to be red                    
                    if (StopLight4 == False):
                        #count every second (counter2 starts from 0)
                        second = counter5 % 60
                        #if it has been one second, isSecond is true
                        if second == 0:
                            isSecond = True
                        else:
                            isSecond = False
                        #increment the counter every loop
                        counter5 = counter5 + 1
                        #if it has been one second, take a picture
                        if isSecond == True:
                            image = cameraInterfacingLab.d435Color.imageBufferRGB
                            #--------------------Image Processing------------------------
                            hsv_img = cv2.cvtColor(image, cv2.COLOR_BGR2HSV)
                            carStopped5 = True
                            # lower range of green stoplight color in HSV
                            hsv_green_lower = (40, 50, 100)
                            # upper range of green stoplight color in HSV
                            hsv_green_upper = (80, 255, 255)
                            #mask with the range of greens for stoplight color
                            mask = cv2.inRange(hsv_img, hsv_green_lower, hsv_green_upper)
                            #only show the pixels that contain the stoplight color
                            color_image = cv2.bitwise_and(image, image, mask=mask)

                            print(f"Green pixels: {green_pixels}, Ratio: {green_ratio:.5f}")

                            # --- New threshold logic ---
                            if green_ratio >= 0.0001 and green_pixels >= 50:
                                green_frame_count_4 += 1
                                print(f"Green frame count: {green_frame_count_3}")
                            else:
                                green_frame_count_4 = 0  # reset if not green

                            # Only GO if we have 3 green frames in a row
                            if green_frame_count_4 >= 3:
                            #If the average pixel value is above 0.07, stoplight must be green
                            #if np.average(color_image) >= 0.06: 
                                carStopped6 = False
                                print("Light is green go!")
                                StopLight = True
                                u = speedController.update(v, current_v_ref * speed_multiplier, dt)
                            #otherwise, stop at red light
                            else:
                                print("Light is red stop!")
                                u = 0
                                delta = 0

                #if car is not in region for any stoplight or stopsign
                #run default controller and reset parameters
                else:
                    u = speedController.update(v, current_v_ref * speed_multiplier, dt)
                    StopLight = False
                    StopLight2 = False
                    StopLight3 = False
                    StopLight4 = False
                    carStopped =False
                    carStopped2 = False
                    carStopped3 = False
                    carStopped4 = False
                    carStopped5 = False
                    carStopped6 = False
                    counter2 = 0
                    counter3 = 0
                    counter4 = 0
                    counter5 = 0

                #endregion

                #region : Steering controller update
                if enableSteeringControl:
                    delta = steeringController.update(p, th, v, dt)
                else:
                    delta = 0
                #endregion
            qcar.write(u, delta)
            #endregion

            #region : Update Scopes
            count += 1
            if count >= countMax and t > startDelay:
                t_plot = t - startDelay

                # Speed control scope
                speedScope.axes[0].sample(t_plot, [v, v_ref])
                speedScope.axes[1].sample(t_plot, [v_ref-v])
                speedScope.axes[2].sample(t_plot, [u])

                # Steering control scope
                if enableSteeringControl:
                    steeringScope.axes[4].sample(t_plot, [[p[0],p[1]]])

                    p[0] = ekf.x_hat[0,0]
                    p[1] = ekf.x_hat[1,0]

                    x_ref = steeringController.p_ref[0]
                    y_ref = steeringController.p_ref[1]
                    th_ref = steeringController.th_ref

                    x_ref = gps.position[0]
                    y_ref = gps.position[1]
                    th_ref = gps.orientation[2]

                    steeringScope.axes[0].sample(t_plot, [p[0], x_ref])
                    steeringScope.axes[1].sample(t_plot, [p[1], y_ref])
                    steeringScope.axes[2].sample(t_plot, [th, th_ref])
                    steeringScope.axes[3].sample(t_plot, [delta])


                    arrow.setPos(p[0], p[1])
                    arrow.setStyle(angle=180-th*180/np.pi)

                count = 0
            #endregion
            continue
    cameraInterfacingLab.stop_cameras()    

# -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --

class ImageInterpretation():

    def __init__(self,
            imageSize,
            frameRate,
            streamInfo,
            chessDims,
            boxSize):

        # Camera calibration constants:
        self.NUMBER_IMAGES = 15

        # List of variables given by students
        self.imageSize      = imageSize
        self.chessboardDim  = [chessDims,chessDims]
        self.frameRate      = frameRate
        self.boxSize        = boxSize
        self.sampleRate     = 1/self.frameRate
        self.calibFinished  = False

        self.d435CamIntrinsics = np.eye(3,3,dtype= np.float32)

        self.d435DistParam = np.ones((1,5), dtype= np.float32)

        self.streamD435 = np.zeros((self.imageSize[1][0],self.imageSize[1][1]))

        # Information for interfacing with front CSI camera
        enableCameras = [False, False, False, False]
        enableCameras[streamInfo[0]] = True

        # Information for interfacing with Realsense camera
        self.d435Color = QCarRealSense(
            mode=streamInfo[1],
            frameWidthRGB  = self.imageSize[1][0],
            frameHeightRGB = self.imageSize[1][1],
            frameRateRGB   = self.frameRate[1]
        )

        # Initialize calibration tool:
        self.camCalibTool = ImageProcessing()

        self.SimulationTime = 15
 
    def stop_cameras(self):
        # Stopping the image feed for both cameras
        self.d435Color.terminate()

#endregion

#region : Setup and run experiment
if __name__ == '__main__':

    #region : Setup scopes
    if IS_PHYSICAL_QCAR:
        fps = 10
    else:
        fps = 30
    
    # Scope for monitoring speed controller
    speedScope = MultiScope(
        rows=3,
        cols=1,
        title='Vehicle Speed Control',
        fps=fps
    )
    speedScope.addAxis(
        row=0,
        col=0,
        timeWindow=tf,
        yLabel='Vehicle Speed [m/s]',
        yLim=(0, 1)
    )
    speedScope.axes[0].attachSignal(name='v_meas', width=2)
    speedScope.axes[0].attachSignal(name='v_ref')

    speedScope.addAxis(
        row=1,
        col=0,
        timeWindow=tf,
        yLabel='Speed Error [m/s]',
        yLim=(-0.5, 0.5)
    )
    speedScope.axes[1].attachSignal()

    speedScope.addAxis(
        row=2,
        col=0,
        timeWindow=tf,
        xLabel='Time [s]',
        yLabel='Throttle Command [%]',
        yLim=(-0.3, 0.3)
    )
    speedScope.axes[2].attachSignal()

    # Scope for monitoring steering controller
    if enableSteeringControl:
        steeringScope = MultiScope(
            rows=4,
            cols=2,
            title='Vehicle Steering Control',
            fps=fps
        )

        steeringScope.addAxis(
            row=0,
            col=0,
            timeWindow=tf,
            yLabel='x Position [m]',
            yLim=(-2.5, 2.5)
        )
        steeringScope.axes[0].attachSignal(name='x_meas')
        steeringScope.axes[0].attachSignal(name='x_ref')

        steeringScope.addAxis(
            row=1,
            col=0,
            timeWindow=tf,
            yLabel='y Position [m]',
            yLim=(-1, 5)
        )
        steeringScope.axes[1].attachSignal(name='y_meas')
        steeringScope.axes[1].attachSignal(name='y_ref')

        steeringScope.addAxis(
            row=2,
            col=0,
            timeWindow=tf,
            yLabel='Heading Angle [rad]',
            yLim=(-3.5, 3.5)
        )
        steeringScope.axes[2].attachSignal(name='th_meas')
        steeringScope.axes[2].attachSignal(name='th_ref')

        steeringScope.addAxis(
            row=3,
            col=0,
            timeWindow=tf,
            yLabel='Steering Angle [rad]',
            yLim=(-0.6, 0.6)
        )
        steeringScope.axes[3].attachSignal()
        steeringScope.axes[3].xLabel = 'Time [s]'

        steeringScope.addXYAxis(
            row=0,
            col=1,
            rowSpan=4,
            xLabel='x Position [m]',
            yLabel='y Position [m]',
            xLim=(-2.5, 2.5),
            yLim=(-1, 5)
        )

        im = cv2.imread(
            images.SDCS_CITYSCAPE,
            cv2.IMREAD_GRAYSCALE
        )

        steeringScope.axes[4].attachImage(
            scale=(-0.002035, 0.002035),
            offset=(1125,2365),
            rotation=180,
            levels=(0, 255)
        )
        steeringScope.axes[4].images[0].setImage(image=im)

        referencePath = pg.PlotDataItem(
            pen={'color': (85,168,104), 'width': 2},
            name='Reference'
        )
        steeringScope.axes[4].plot.addItem(referencePath)
        referencePath.setData(waypointSequence[0, :],waypointSequence[1, :])

        steeringScope.axes[4].attachSignal(name='Estimated', width=2)

        arrow = pg.ArrowItem(
            angle=180,
            tipAngle=60,
            headLen=10,
            tailLen=10,
            tailWidth=5,
            pen={'color': 'w', 'fillColor': [196,78,82], 'width': 1},
            brush=[196,78,82]
        )
        arrow.setPos(initialPose[0], initialPose[1])
        steeringScope.axes[4].plot.addItem(arrow)
    #endregion

    #region : Setup control thread, then run experiment
    controlThread = Thread(target=controlLoop)
    controlThread.start()

    try:
        while controlThread.is_alive() and (not KILL_THREAD):
            MultiScope.refreshAll()
            time.sleep(0.01)
    finally:
        KILL_THREAD = True
    #endregion
    if not IS_PHYSICAL_QCAR:
        #qlabs_setup.terminate()
        #Setup_Competition.terminate()

        input('Experiment complete. Press any key to exit...')
#endregion
